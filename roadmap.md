# Roadmap Улучшений Проекта Бота

Этот документ описывает план по дальнейшему улучшению и рефакторингу Telegram-бота.

## Текущее Состояние Проекта (Обзор и Анализ)

На момент составления этого документа, проект Telegram-бота обладает следующими характеристиками и функционалом:

### Что Реализовано и Работает:

1.  **Базовый функционал бота:**
    *   Прием и обработка команд в личных сообщениях и группах.
    *   Использование `aiogram 3.x` в качестве основы.
    *   Настройка и управление через переменные окружения (`.env` файл, `pydantic-settings`).
2.  **Управление чатами и их активация:**
    *   Механизм добавления бота в чат и его последующей активации владельцем бота.
    *   Администраторы чата могут запросить настройку, отправив код, полученный в ЛС, в группу.
    *   Владелец бота получает уведомление и может одобрить/отклонить активацию, а также выдать особый доступ администратору чата.
    *   Команда `/rmchat` для администраторов группы для удаления чата из БД бота (с подтверждением).
3.  **Управление каналами для подписки:**
    *   Администраторы (после активации чата владельцем или если это сам владелец) могут управлять списком каналов, на которые должны быть подписаны пользователи.
    *   Реализовано через FSM (`ChannelManagementService`) в личных сообщениях с ботом, с возможностью добавлять каналы (через `ChatShared`) и удалять их из списка.
    *   Интерфейс управления каналами (`/chats` -> "Управлять" или `/channels` в группе для админов, или напрямую после активации).
4.  **Проверка подписки на каналы:**
    *   `SubscriptionService` отвечает за проверку подписки пользователя на обязательные каналы чата.
    *   Используется кэширование результатов проверки подписки (`user_channel_cache`, `failed_check_cache`) для снижения нагрузки на Telegram API.
    *   При отсутствии подписки пользователю отправляется предупреждение с кнопкой "Я подписался".
    *   Реализован счетчик неудачных проверок (`sub_fail_count`): после 3 неудач пользователь получает мут на 25 часов.
    *   Кнопка "Я подписался" (`handle_subcheck_callback`) проверяет фактическую подписку и корректно обрабатывает нажатие только целевым пользователем.
5.  **Система Капчи:**
    *   `CaptchaService` управляет логикой капчи.
    *   Капча отправляется новым пользователям при входе в чат (если включена в настройках чата и чат активирован).
    *   Пользователь временно ограничивается в правах (мут на 60 минут), пока не пройдет капчу.
    *   При успешном прохождении капчи (нажатие кнопки) ограничения снимаются, сообщение с капчей редактируется/удаляется.
    *   Сообщения от пользователей, не прошедших капчу, удаляются (если капча включена).
6.  **Команды и Роутинг:**
    *   Разделение хэндлеров по файлам (`private_messages.py`, `group_messages.py`, `admin.py`, `group_admin.py`, `callbacks.py`, `fsm_private.py`).
    *   Использование `Router` для структурирования хэндлеров.
    *   Реализованы команды для пользователей (`/start`, `/help`, `/code`, `/chats`) и администраторов групп (`/channels`, `/captcha`, `/subcheck`, `/rmchat`).
    *   Настройка команд меню бота (`set_my_commands`).
7.  **База данных (`SQLite` через `aiosqlite`):**
    *   `DatabaseManager` инкапсулирует всю работу с БД.
    *   Хранение настроек чатов (`chat_settings`), статусов пользователей в чатах (`user_chat_status`), связанных каналов (`linked_channels`), информации о боте (`bot_info`), кодов активации (`activation_codes`), сообщений для очистки (`bot_messages_for_cleanup`).
    *   Реализованы базовые миграции схемы (`run_migrations`).
8.  **Логирование:**
    *   Используется стандартный модуль `logging` с `colorlog` для цветного вывода в консоль и записи в файл (`logs/bot.log`).
    *   Различные уровни логирования, форматирование сообщений логов.
    *   Фоновая задача `clean_logs_task` для очистки старых логов по достижению лимита размера папки.
9.  **Фоновые задачи (`aioschedule` и `asyncio.create_task`):**
    *   Очистка старых сообщений бота (`clean_old_bot_messages`).
    *   Очистка логов (`clean_logs_task`).
    *   Ежедневные напоминания владельцу об неактивированных чатах (`send_daily_activation_reminders`).
    *   Обновление кэша подписок в `SubscriptionService` (косвенно через `get_subscribed_users_for_channel`, который может вызываться периодически, если такая логика будет добавлена).
10. **Конфигурация:**
    *   Использование `pydantic-settings` для загрузки настроек из `.env` файла.
11. **Middleware:**
    *   `DbSessionMiddleware` для передачи `db_manager` в хэндлеры.
    *   `BotMiddleware` для передачи экземпляра `bot` в хэндлеры.
    *   Сервисы (`SubscriptionService`, `CaptchaService`) передаются через `workflow_data` диспетчера.

### Что Сделано Хорошо:

*   **Структура проекта:** В целом логичная, с разделением на `handlers`, `services`, `db`, `utils`, `middlewares`, `states`, `data`.
*   **Асинхронность:** Активное использование `async/await` и `aiogram`.
*   **Управление зависимостями (частично):** Начато внедрение передачи зависимостей (как `db_manager`, `bot`, сервисы) в конструкторы или через `workflow_data`, что улучшает тестируемость (особенно после рефакторинга `CaptchaService`).
*   **Работа с FSM:** Корректное использование машины состояний для сложных сценариев, таких как управление каналами.
*   **Обработка CallbackQuery:** Использование `CallbackData` для структурированных данных в кнопках.
*   **Логирование:** Наличие системы логирования с ротацией и форматированием.
*   **Конфигурация:** Современный подход с `pydantic-settings`.
*   **Безопасность (основы):** Проверка прав администраторов для выполнения команд, параметризованные запросы к БД.
*   **Комментарии к коду:** В большинстве случаев код содержит комментарии, поясняющие логику.
*   **Форматирование Markdown/HTML:** Использование хелперов `hcode`, `hlink`, `hbold` для красивого форматирования сообщений.

### Что Можно Улучшить / На Что Обратить Внимание (Кратко):

*   **DI для `SubscriptionService`:** Требуется рефакторинг для передачи `db_manager` через конструктор (см. Roadmap II.1).
*   **Обработка ошибок в фоновых задачах:** Усилить `try-except` блоки (см. Roadmap I.1).
*   **Консистентность лог-форматеров:** Объединить `format_captcha_log` и `format_log_message` (см. Roadmap II.3).
*   **Использование Enum для `action` в `CallbackData`:** Повысит надежность (см. Roadmap II.4).
*   **Индексы в БД:** Могут улучшить производительность запросов (см. Roadmap III.1).
*   **Транзакции в БД:** Для атомарности сложных операций (см. Roadmap III.2).
*   **Миграции БД:** Улучшить обработку значений по умолчанию и рассмотреть более сложные сценарии миграций (см. Roadmap III.3).
*   **Настройка длительности мутов:** Вынести в конфиг (см. Roadmap IV.4).
*   **Тестирование:** Отсутствие автоматических тестов (модульных, интеграционных) (см. Roadmap V).
*   **Удаление неиспользуемого кода/импортов:** Требуется периодическая чистка (см. Roadmap II.5, II.6).
*   **Локализация:** Отсутствует, все строки на русском (см. Roadmap IV.1).
*   **Проверка `BOT_OWNER_ID`:** Сделать более повсеместной (см. Roadmap I.2).
*   **Отказоустойчивость `get_chat`:** Стандартизировать обработку ошибок (см. Roadmap I.4).

Этот обзор должен дать общее представление о текущем состоянии проекта перед началом работы по Roadmap.

## I. Стабильность и Надежность

### 1. Обработка исключений в фоновых задачах
*   **Цель:** Гарантировать, что падение одной фоновой задачи не остановит остальные и не приведет к падению всего бота. Обеспечить полное логирование ошибок.
*   **Где смотреть:**
    *   `bot/__main__.py`: Функции `send_daily_activation_reminders`, `clean_old_bot_messages`, `clean_logs_task`, `run_scheduled_tasks`.
*   **Что делать:**
    *   Убедиться, что каждая из этих функций (и цикл `while True` внутри них, если есть) обернута в `try...except Exception as e:` верхнего уровня.
    *   В блоке `except` логировать ошибку с помощью `logger.error(f"Ошибка в задаче X: {e}", exc_info=True)`. `exc_info=True` очень важен для получения полного стека вызовов.
    *   Для `run_scheduled_tasks` (обработчик `aioschedule`) мы уже добавили `try-except`. Проверить его актуальность.
    *   Подумать, нужно ли в случае некоторых ошибок делать `await asyncio.sleep()` перед следующей итерацией цикла, чтобы избежать слишком частого повторения ошибок.
*   **Пример (для `clean_logs_task`):**
    ```python
    async def clean_logs_task():
        await asyncio.sleep(60)
        logger.info("Запущена фоновая задача очистки логов.")
        while True:
            try:
                # ... основная логика задачи ...
            except Exception as e:
                logger.error(f"Критическая ошибка в задаче clean_logs_task: {e}", exc_info=True)
            await asyncio.sleep(3600) # Пауза перед следующей проверкой
    ```

### 2. Проверка `BOT_OWNER_ID`
*   **Цель:** Предотвратить ошибки и некорректное поведение, если `BOT_OWNER_ID` не сконфигурирован, в функциях, которые на него полагаются.
*   **Где смотреть:**
    *   `bot/__main__.py`: `send_daily_activation_reminders`.
    *   Любые другие места, где `BOT_OWNER_ID` используется для отправки уведомлений владельцу или для проверки прав (например, фильтры `owner_only_private_...` в `bot/handlers/admin.py`).
*   **Что делать:**
    *   Перед использованием `BOT_OWNER_ID` проверять `if not BOT_OWNER_ID:`.
    *   Если ID не задан, логировать `logger.warning("BOT_OWNER_ID не настроен. Функция X не будет работать корректно / уведомление не будет отправлено.")`.
    *   В зависимости от функции, либо прерывать выполнение этой части логики (return/continue), либо продолжать без нее, если это возможно.
    *   Для фильтров: если `BOT_OWNER_ID` не задан, фильтр должен всегда возвращать `False`.

### 3. Тайм-ауты и повторные попытки для API-запросов
*   **Цель:** Повысить устойчивость к временным сбоям сети или API Telegram.
*   **Где смотреть:**
    *   Критические вызовы API Telegram: `bot.send_message`, `bot.edit_message_text`, `bot.delete_message`, `bot.restrict_chat_member`, `bot.leave_chat`, etc. Особенно те, что не обернуты в специфическую логику повторов.
    *   `bot/services/captcha.py`: `_delete_message_after_delay` уже имеет пример такой логики.
*   **Что делать:**
    *   Для очень важных операций, где простой сбой недопустим, можно обернуть вызов в цикл с несколькими попытками и увеличивающейся задержкой (`asyncio.sleep`).
    *   Логировать каждую попытку и ошибку.
    *   Учитывать типы ошибок: некоторые ошибки (например, `ChatNotFound`, `UserDeactivated`) не имеет смысла повторять. Другие (`RetryAfter`, временные сетевые проблемы) – имеет.
    *   **Примечание:** `aiogram` сама по себе может иметь некоторую логику обработки `RetryAfter`. Стоит изучить, покрывает ли она все необходимые случаи, или ручная обработка все же нужна.

### 4. Отказоустойчивость `bot.get_chat()` и подобных
*   **Цель:** Избежать падений, если информация о чате/пользователе не может быть получена.
*   **Где смотреть:** Все вызовы `bot.get_chat()`, `bot.get_chat_member()`.
*   **Что делать:**
    *   Обернуть вызовы в `try...except TelegramAPIError as e:`.
    *   В блоке `except` логировать ошибку: `logger.warning(f"Не удалось получить информацию о chat/user {identifier}: {e}")`.
    *   Предоставить "запасное" значение, если информация не получена (например, использовать `chat_id` вместо `chat.title`, если `title` недоступен).
    *   Пример:
        ```python
        chat_title_display = f"ID {chat_id}"
        try:
            chat_info = await bot.get_chat(chat_id)
            chat_title_display = chat_info.title or chat_title_display
        except TelegramAPIError as e:
            logger.warning(f"Не удалось получить title для чата {chat_id}: {e}")
        # Дальше использовать chat_title_display
        ```

## II. Качество Кода и Архитектура

### 1. Рефакторинг `SubscriptionService` (DI для `db_manager`)
*   **Цель:** Улучшить тестируемость и консистентность с `CaptchaService`.
*   **Где смотреть:**
    *   `bot/services/subscription.py`
    *   `bot/__main__.py` (место создания `SubscriptionService`)
*   **Что делать:**
    *   В `bot/services/subscription.py`:
        *   Удалить импорт: `from bot.bot_instance import db_manager`.
        *   Изменить конструктор `__init__`:
            ```python
            # class SubscriptionService:
            #     def __init__(self, bot: Bot): # СТАРЫЙ
            #         self.bot = bot
            #         self.db_manager = db_manager # Использует импортированный экземпляр
            
            class SubscriptionService:
                def __init__(self, bot: Bot, db_manager: DatabaseManager): # НОВЫЙ
                    self.bot = bot
                    self.db_manager = db_manager # Использует переданный экземпляр
            ```
        *   Все вызовы `db_manager` внутри класса теперь будут использовать `self.db_manager`.
    *   В `bot/__main__.py`:
        *   При создании экземпляра `SubscriptionService`, передать `bi.db_manager`:
            ```python
            # subscription_service = SubscriptionService(bi.bot) # СТАРОЕ
            subscription_service = SubscriptionService(bi.bot, bi.db_manager) # НОВОЕ
            ```

### 2. Middleware
*   **Цель:** Убедиться, что мидлвэри используются эффективно и только при необходимости.
*   **Где смотреть:**
    *   Все файлы роутеров в `bot/handlers/`.
    *   Файлы мидлвэрей в `bot/middlewares/`.
*   **Что делать:**
    *   Просмотреть каждый роутер. Если роутер (или его хэндлеры) не выполняет операций с базой данных, то ему не нужен `DbSessionMiddleware(db_manager)`. Аналогично для `BotMiddleware`.
    *   Сейчас они регистрируются почти везде. Это не критическая проблема, но может немного снижать производительность, если объект создается и передается без необходимости.

### 3. Консистентность форматеров логов
*   **Цель:** Сделать логи более единообразными и упростить их анализ.
*   **Где смотреть:**
    *   `bot/services/captcha.py`: функция `format_captcha_log`.
    *   `bot/handlers/group_messages.py`: функция `format_log_message`.
*   **Что делать:**
    *   Проанализировать обе функции. Они очень похожи.
    *   Создать одну общую функцию-хелпер, например, в `bot/utils/helpers.py` или в новом `bot/utils/logging_utils.py`.
    *   Эта новая функция должна принимать все необходимые параметры (тип лога, chat_id, chat_title, user_id, user_name, message_id, основной текст сообщения и т.д.) и возвращать стандартизированную строку лога.
    *   Заменить вызовы `format_captcha_log` и `format_log_message` на вызовы новой общей функции.

### 4. Использование `enums` для `callback_data` actions
*   **Цель:** Повысить надежность кода, уменьшить вероятность ошибок из-за опечаток в строковых константах.
*   **Где смотреть:**
    *   `bot/data/callback_data.py`: все классы, наследуемые от `CallbackData`.
    *   Места использования этих коллбэков (фильтры и хэндлеры) в `bot/handlers/`.
*   **Что делать:**
    *   Для каждого `CallbackData`, где поле `action` (или аналогичное) используется для определения типа операции, создать `Enum`.
    *   Пример:
        ```python
        # В bot/data/callback_data.py
        from enum import Enum
        class OwnerActivationAction(Enum):
            APPROVE = "approve"
            APPROVE_GRANT = "approve_grant"
            REJECT = "reject"

        class OwnerActivationChoiceCallback(CallbackData, prefix="owner_act"):
            action: OwnerActivationAction # Тип поля теперь Enum
            target_user_id: int
            target_chat_id: int
        ```
    *   В хэндлерах при фильтрации и проверке использовать члены Enum:
        ```python
        # from bot.data.callback_data import OwnerActivationAction # Импортировать Enum
        # @admin_router.callback_query(OwnerActivationChoiceCallback.filter(F.action == OwnerActivationAction.APPROVE), ...)
        # async def handle_owner_approve_activation(...):
        #     if callback_data.action == OwnerActivationAction.APPROVE:
        #         # ...
        ```

### 5. Удаление закомментированного кода
*   **Цель:** Улучшить читаемость кода, убрать "мертвый" код.
*   **Где смотреть:** Весь проект.
*   **Что делать:**
    *   Систематически пройти по всем файлам `.py`.
    *   Удалить большие закомментированные блоки кода, которые являются остатками старых версий функций или отладки.
    *   Оставлять комментарии только для объяснения сложной или неочевидной логики.
    *   Использовать систему контроля версий (git) для доступа к истории кода, если потребуется старый вариант.

### 6. Проверка импортов
*   **Цель:** Поддерживать чистоту кода, удалять неиспользуемые зависимости.
*   **Где смотреть:** Весь проект.
*   **Что делать:**
    *   Использовать линтер (например, `flake8` с плагином `flake8-import-order` или `isort`) для автоматической проверки и форматирования импортов.
    *   Линтер также укажет на неиспользуемые импорты.
    *   Группировка:
        1.  Импорты стандартной библиотеки Python (e.g., `import os`, `import logging`).
        2.  Импорты сторонних библиотек (e.g., `from aiogram import Bot`).
        3.  Импорты из текущего проекта (e.g., `from ..db.database import DatabaseManager`).
    *   Сортировка импортов в каждой группе по алфавиту.

## III. База Данных

### 1. Индексы
*   **Цель:** Ускорить выполнение запросов к базе данных.
*   **Где смотреть:**
    *   `bot/db/database.py`: схема таблиц (`CREATE TABLE` запросы).
    *   Методы `DatabaseManager`, выполняющие `SELECT` запросы с условиями `WHERE`.
*   **Что делать:**
    *   Проанализировать, по каким полям чаще всего происходит поиск или фильтрация.
    *   Для этих полей добавить индексы.
    *   Примеры потенциальных индексов:
        *   `CREATE INDEX IF NOT EXISTS idx_user_chat_status_user_chat ON user_chat_status (user_id, chat_id);` (уже может быть покрыто PRIMARY KEY, если он композитный, но явный индекс не помешает для других комбинаций)
        *   `CREATE INDEX IF NOT EXISTS idx_user_chat_status_captcha ON user_chat_status (captcha_passed);`
        *   `CREATE INDEX IF NOT EXISTS idx_user_chat_status_sub_fail ON user_chat_status (sub_fail_count);`
        *   `CREATE INDEX IF NOT EXISTS idx_chat_settings_chat_id ON chat_settings (chat_id);` (если `chat_id` не PRIMARY KEY)
        *   `CREATE INDEX IF NOT EXISTS idx_linked_channels_chat_id ON linked_channels (chat_id);`
        *   `CREATE INDEX IF NOT EXISTS idx_bot_messages_cleanup_chat_message ON bot_messages_for_cleanup (chat_id, message_id);`
        *   `CREATE INDEX IF NOT EXISTS idx_bot_messages_cleanup_created_at ON bot_messages_for_cleanup (created_at);`
    *   Добавлять индексы в методе `_create_tables` или в отдельном методе, вызываемом при инициализации БД.
    *   **Важно:** Не создавать слишком много индексов, так как они замедляют операции `INSERT` и `UPDATE`. Индексировать только часто используемые в `WHERE`, `JOIN`, `ORDER BY` поля.

### 2. Транзакции
*   **Цель:** Обеспечить атомарность операций, состоящих из нескольких запросов к БД.
*   **Где смотреть:**
    *   Операции, где несколько `INSERT`, `UPDATE`, `DELETE` должны выполниться успешно все вместе, или ни один из них.
    *   Примеры:
        *   Сохранение настроек чата и связанных каналов (`ChannelManagementService.handle_finish_channel_management`).
        *   Регистрация нового пользователя с установкой начальных статусов.
*   **Что делать:**
    *   Использовать `async with self.conn.cursor() as cur: await cur.execute("BEGIN") ... await cur.execute("COMMIT")` или `async with self.conn: ...` (второе автоматически управляет транзакцией для `aiosqlite`, если не было явного BEGIN).
    *   В случае ошибки внутри блока `try` выполнять `await cur.execute("ROLLBACK")` (если BEGIN был явным) или просто позволить исключению выйти из `async with self.conn:`, что вызовет откат.
    *   Пример:
        ```python
        # async def some_complex_db_operation(self, ...):
        #     try:
        #         async with self.conn: # Автоматический BEGIN/COMMIT/ROLLBACK
        #             await self.conn.execute("UPDATE table1 SET ... WHERE ...", (...))
        #             await self.conn.execute("INSERT INTO table2 (...) VALUES (...)", (...))
        #             # Если здесь возникнет исключение, conn.__aexit__ сделает ROLLBACK
        #     except aiosqlite.Error as e:
        #         logger.error(f"Ошибка транзакции: {e}")
        #         # Обработка ошибки, возможно, re-raise
        ```

### 3. Миграции (`run_migrations` в `database.py`)
*   **Цель:** Более надежное и гибкое управление изменениями схемы БД.
*   **Где смотреть:** `bot/db/database.py`, метод `run_migrations`.
*   **Что делать:**
    *   **Значения по умолчанию при добавлении столбцов:** Когда добавляется новый столбец (например, `is_premium_ignored`), рассмотреть необходимость обновления существующих записей. Если столбец `NOT NULL` и не имеет `DEFAULT` в схеме, это может вызвать проблемы. Можно либо добавить `DEFAULT` в `ALTER TABLE`, либо выполнить `UPDATE` после `ALTER TABLE` для установки начальных значений.
    *   **Более сложные миграции:** Если потребуются переименования таблиц/столбцов или изменения типов данных, текущий подход "добавить если нет" может быть недостаточен. Для таких случаев:
        1.  Создавать новую таблицу с нужной структурой.
        2.  Копировать данные из старой таблицы в новую с необходимыми преобразованиями.
        3.  Удалять старую таблицу.
        4.  Переименовывать новую таблицу в имя старой.
        *   Все эти шаги должны выполняться в рамках одной транзакции.
    *   Рассмотреть простой механизм версионирования миграций (например, таблица `schema_version` в БД, хранящая номер последней примененной миграции), чтобы применять только новые миграции. Для небольшого проекта на `sqlite` это может быть избыточно, если изменения схемы редки.

## IV. Функционал и UX

### 1. Локализация/Переводы
*   **Цель:** Подготовить бота к поддержке нескольких языков.
*   **Где смотреть:** Все строки текста, отправляемые пользователям.
*   **Что делать:**
    *   Выбрать систему локализации (например, `aiogram.utils.i18n.I18NMiddleware` с форматом `.po`/`.mo` файлов).
    *   Вынести все пользовательские строки в файлы локализации (например, `locales/ru/LC_MESSAGES/bot.po`, `locales/en/LC_MESSAGES/bot.po`).
    *   Обернуть строки в коде в функции для перевода (например, `_("Текст для перевода")`).
    *   Настроить мидлвэр для определения языка пользователя и загрузки нужных переводов.

### 2. Обратная связь пользователю
*   **Цель:** Сделать взаимодействие с ботом более понятным и дружелюбным.
*   **Где смотреть:**
    *   Блоки `except` в хэндлерах и сервисах.
    *   Места, где выполняются потенциально длительные операции.
*   **Что делать:**
    *   Вместо общих сообщений типа "Произошла ошибка", по возможности давать более конкретную информацию (если это безопасно и не раскрывает внутреннюю структуру). Например: "Не удалось найти канал X. Проверьте правильность написания."
    *   Для команд, которые могут занять некоторое время, использовать `await bot.send_chat_action(chat_id=..., action="typing")` перед началом операции.
    *   Если операция завершилась неудачно, но ошибка обработана, сообщить пользователю, что что-то пошло не так, и, возможно, предложить попробовать позже или обратиться к администратору.

### 3. Команды в `/help`
*   **Цель:** Предоставить пользователям актуальную справку.
*   **Где смотреть:**
    *   `bot/handlers/private_messages.py`: хэндлер команды `/help`.
    *   `bot/utils/bot_commands.py` и `bot/__main__.py`: функция `setup_bot_commands`.
*   **Что делать:**
    *   Проверить список команд в `setup_bot_commands`.
    *   Убедиться, что все команды, перечисленные в `/help`, действительно реализованы и работают.
    *   Удалить из справки упоминания устаревших или удаленных команд.
    *   Убедиться, что описание команд в справке соответствует их текущему функционалу и названиям.
    *   Мы уже использовали `hcode()` для форматирования команд в справке, это хорошо.

### 4. Настройка мутов
*   **Цель:** Сделать длительность ограничений более гибкой.
*   **Где смотреть:**
    *   `bot/services/captcha.py`: `start_captcha_for_user` (мут на 60 минут).
    *   `bot/handlers/group_messages.py`: мут на 25 часов за отсутствие подписки.
*   **Что делать:**
    *   Вынести значения длительности мутов (60 минут, 25 часов) в файл конфигурации `bot/config.py` (например, `CAPTCHA_MUTE_DURATION_SECONDS`, `SUBSCRIPTION_FAIL_MUTE_DURATION_SECONDS`).
    *   Загружать эти значения из `settings`.
    *   *Опционально (более сложный вариант):* Добавить возможность настраивать эти длительности для каждого чата отдельно через БД (новая таблица или поля в `chat_settings`). Это потребует изменений в интерфейсе управления чатом.

## V. Тестирование

### 1. Модульные тесты
*   **Цель:** Обеспечить корректность работы отдельных компонентов (сервисов, сложных функций) и упростить рефакторинг.
*   **Где смотреть:**
    *   `bot/services/subscription.py`
    *   `bot/services/captcha.py`
    *   `bot/services/channel_mgmt.py`
    *   Сложные хелперы в `bot/utils/helpers.py`.
*   **Что делать:**
    *   Использовать фреймворк для тестирования (например, `pytest`).
    *   Создать каталог `tests/` в корне проекта.
    *   Для каждого тестируемого модуля/класса создать соответствующий файл теста (e.g., `tests/services/test_subscription_service.py`).
    *   Использовать "моки" (mocks, например, из `unittest.mock` или `pytest-mock`) для имитации зависимостей (например, `Bot`, `DatabaseManager`).
    *   Тестировать различные сценарии: успешное выполнение, обработка ошибок, граничные случаи.
    *   Пример (очень упрощенно для `SubscriptionService`):
        ```python
        # tests/services/test_subscription_service.py
        # from unittest.mock import AsyncMock
        # import pytest
        # from bot.services.subscription import SubscriptionService
        
        # @pytest.mark.asyncio
        # async def test_check_subscription_user_subscribed():
        #     mock_bot = AsyncMock()
        #     mock_db_manager = AsyncMock()
        #     # Настроить мок db_manager.get_linked_channels_for_chat(...)
        #     # Настроить мок bot.get_chat_member(...)
        #     service = SubscriptionService(mock_bot, mock_db_manager)
        #     is_subscribed, missing = await service.check_subscription(user_id=123, chat_id=-100)
        #     assert is_subscribed is True
        #     assert not missing
        ```

### 2. Интеграционные тесты
*   **Цель:** Проверить корректность взаимодействия между несколькими компонентами системы.
*   **Где смотреть:** Сценарии, включающие хэндлер -> сервис -> БД.
*   **Что делать:**
    *   Также использовать `pytest`.
    *   Могут требовать настройки тестовой БД (например, `sqlite` в памяти).
    *   Тестировать полные сценарии: отправка команды боту, проверка реакции бота, проверка изменений в БД.
    *   Эти тесты сложнее в написании и поддержке, чем модульные, поэтому стоит сосредоточиться на наиболее критичных сценариях.

## VI. Безопасность

### 1. Проверка прав в коллбэках
*   **Цель:** Предотвратить несанкционированный доступ к функциям через коллбэк-кнопки.
*   **Где смотреть:** Все хэндлеры `callback_query` в `bot/handlers/`, особенно те, что выполняют административные действия.
*   **Что делать:**
    *   Мы уже добавили фильтры `owner_only_private_filter_debug_cq` и `owner_only_private_message_filter` в `bot/handlers/admin.py`. Убедиться, что они корректно работают и применяются ко всем нужным хэндлерам.
    *   Для коллбэков, которые должны нажиматься только определенным пользователем (не обязательно владельцем, например, кнопка "Я не робот" в капче), проверять `callback_query.from_user.id` с ожидаемым ID (который может быть сохранен в `callback_data`). Мы уже делаем это для капчи и кнопки проверки подписки.
    *   Для действий, которые может выполнять только админ чата (например, коллбэки в `ChannelManagementService`, если бы они были доступны в группе), необходимо получать `callback_query.message.chat.id` и `callback_query.from_user.id` и проверять права через `is_admin(...)`.

### 2. SQL-инъекции
*   **Цель:** Предотвратить атаки на базу данных.
*   **ГДЕ:** `bot/db/database.py`.
*   **ЧТО:** Продолжать использовать параметризованные запросы (с `?` в SQL-строке и передачей параметров вторым аргументом в `execute`). Никогда не формировать SQL-запросы путем прямой конкатенации строк с данными, полученными от пользователя или из других ненадежных источников. Текущий код в основном следует этому правилу.

### 3. Ограничение частоты запросов (Rate Limiting)
*   **Цель:** Защита от флуда и злоупотреблений.
*   **Где смотреть:** Потенциально ресурсоемкие команды или операции.
*   **Что делать:**
    *   `aiogram` имеет встроенный механизм троттлинг-мидлвэра (`ThrottleMiddleware`). Его можно настроить и подключить для ограничения частоты вызова определенных хэндлеров от одного пользователя.
    *   Пример использования:
        ```python
        # В __main__.py или где настраивается Dispatcher
        # from aiogram.contrib.middlewares.throttling import ThrottlingMiddleware
        # dp.middleware.setup(ThrottlingMiddleware(rate_limit=0.5)) # Не более 1 сообщения за 0.5 сек от пользователя
        ```
    *   Можно применять троттлинг к конкретным роутерам или хэндлерам.

Этот Roadmap должен помочь любому разработчику быстрее войти в курс дела и планомерно улучшать проект. 