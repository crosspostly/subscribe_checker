# План разработки (TODO)

## Этап 0: Подготовка и настройка

- [ ] Создать Google Таблицу по шаблону, описанному в `README.md`.
- [ ] Заполнить лист `Config` реальными `chat_id` и `channel_id`.
- [ ] Заполнить лист `Messages` всеми необходимыми текстами сообщений.
- [ ] Создать проект в Google Apps Script.
- [ ] Создать все `.gs` файлы-заглушки (`Webhook.gs`, `CoreLogic.gs`, и т.д.).
- [ ] В `Файл > Свойства проекта > Свойства скрипта` добавить переменные `BOT_TOKEN` и `SPREADSHEET_ID`.

## Этап 1: Базовые модули (Работа с данными и API)

### `Settings.gs`
- [ ] Реализовать функцию `getSetting(key)`, которая читает настройку из `CacheService`.
- [ ] Реализовать функцию `getMessage(key)`, которая читает текст сообщения из `CacheService`.
- [ ] Реализовать функцию `loadSettingsAndMessagesToCache()`, которая принудительно загружает все данные с листов "Config" и "Messages" в `CacheService`. Добавить вызов этой функции в начало ключевых операций.

### `SheetManager.gs`
- [ ] Реализовать `findUserRow(userId)`: ищет пользователя и возвращает номер строки и все его данные. Основа для всех операций с пользователем.
- [ ] Реализовать `updateUserData(rowNumber, data)`: обновляет данные пользователя в найденной строке, используя `getValues/setValues` для эффективности.
- [ ] Реализовать `addNewUser(userData)`: добавляет новую строку с данными пользователя.
- [ ] Реализовать `isUserInWhitelist(userId)`: проверяет наличие пользователя на листе "Whitelist".
- [ ] Реализовать `getAllUsers()`: получает всех пользователей для пакетных операций (например, очистка).

### `TelegramAPI.gs`
- [ ] Реализовать главную функцию-обертку `safeTelegramApiCall(method, payload)`:
    - [ ] Интегрировать `LockService` для предотвращения гонок.
    - [ ] Интегрировать `CacheService` для базового rate limiting (пауза между вызовами).
    - [ ] Установить `muteHttpExceptions: true` и добавить логику обработки ошибок от API Telegram.
- [ ] Создать функции-помощники, использующие `safeTelegramApiCall`:
    - [ ] `sendMessage(chatId, text, replyMarkup)`
    - [ ] `deleteMessage(chatId, messageId)`
    - [ ] `restrictChatMember(chatId, userId, permissions, untilDate)`
    - [ ] `getChatMember(chatId, userId)`

## Этап 2: Обработка событий и основная логика

### `Webhook.gs`
- [ ] Реализовать `doPost(e)`: парсит `update` от Telegram и вызывает `CoreLogic.handleUpdate(update)`.
- [ ] Реализовать `setWebhook()`: читает URL развертывания и токен, затем отправляет запрос в Telegram для установки вебхука.

### `Triggers.gs`
- [ ] Реализовать `createOneTimeTrigger(functionName, delayInMinutes, args)`: универсальная функция для создания одноразовых триггеров.
- [ ] Реализовать `captchaTimeoutHandler(e)`: функция, вызываемая триггером. Принимает `userId` из аргументов триггера, проверяет, прошел ли юзер капчу. Если нет — кик.
- [ ] Реализовать `unrestrictHandler(e)`: функция, вызываемая триггером. Снимает ограничения с пользователя.
- [ ] Реализовать `setupHourlyCleanupTrigger()`: функция для одноразового запуска, которая установит периодический триггер для очистки.
- [ ] Реализовать `cleanupRoutine()`: основная функция очистки. Находит пользователей с истекшим сроком мута и просроченных пользователей в состоянии `PENDING_...`.

### `CoreLogic.gs`
- [ ] `handleUpdate(update)`: главный диспетчер. Определяет тип `update` (`new_chat_member`, `message` и т.д.) и вызывает соответствующий обработчик.
- [ ] `handleNewChatMember(update)`:
    - [ ] Проверить, не бот ли это. Если да — выход.
    - [ ] Проверить `Whitelist`.
    - [ ] Если капча включена: вызвать `sendCaptcha`, добавить пользователя в `Users` со статусом `PENDING_CAPTCHA`, создать триггер на таймаут капчи.
    - [ ] Если капча выключена: сразу перейти к `handleSubscriptionCheck`.
- [ ] `handleMessage(message)`:
    - [ ] Найти пользователя в `Users`. Если его нет, возможно, он старый участник — запустить для него `handleSubscriptionCheck`.
    - [ ] Если статус `PENDING_CAPTCHA`: обработать ответ как попытку решить капчу (`processCaptchaReply`).
    - [ ] Если статус `RESTRICTED`: удалить сообщение.
    - [ ] В остальных случаях: запустить `handleSubscriptionCheck` для этого пользователя и его сообщения.
- [ ] `handleSubscriptionCheck(userId, message)`:
    - [ ] Вызвать `getChatMember` (с кешированием результата на ~5 минут в `CacheService`).
    - [ ] **Подписан:** Убедиться, что статус `ACTIVE`.
    - [ ] **Не подписан:** Вызвать `applyViolationPenalty`, передав пользователя и сообщение для удаления.
- [ ] `applyViolationPenalty(user, message)`:
    - [ ] Удалить сообщение нарушителя.
    - [ ] Увеличить `violation_count`.
    - [ ] Отправить соответствующее предупреждение из `Messages`.
    - [ ] Если `violation_count` достиг порога — вызвать `restrictChatMember`, обновить статус на `RESTRICTED` и создать триггер на снятие мута.

## Этап 3: Тестирование и развертывание

- [ ] Провести полное ручное тестирование всех сценариев.
    - [ ] Вход нового пользователя (капча вкл/выкл).
    - [ ] Решение/провал/игнорирование капчи.
    - [ ] Отправка сообщений без подписки (1, 2, 3+ раз).
    - [ ] Автоматическое снятие ограничения.
    - [ ] Работа белого списка.
    - [ ] Корректное удаление сервисных сообщений (приветствий, капчи).
- [ ] Развернуть финальную версию веб-приложения.
- [ ] Установить вебхук через `setWebhook()`.
- [ ] Установить триггер очистки через `setupHourlyCleanupTrigger()`.
